var documenterSearchIndex = {"docs":
[{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"EditURL = \"https://github.com/Yuan-Ru-Lin/IceCubePublicDataReader.jl/blob/main/examples/demo.jl\"","category":"page"},{"location":"generated/demo/#Demonstration","page":"Demonstration","title":"Demonstration","text":"","category":"section"},{"location":"generated/demo/#I/O","page":"Demonstration","title":"I/O","text":"","category":"section"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"This package provides basic I/O and print utility for Event.","category":"page"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"using IceCubePublicDataReader\n\ndemo_file_path = joinpath(pkgdir(IceCubePublicDataReader),\n    \"data\",\n    \"Level1_IC59_data_Run00115150_Part00000000_Event11.odf\")\n\nevent = open(demo_file_path) do io\n    read(io, Event)\nend","category":"page"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"You can also write an Event out.","category":"page"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"buffer = IOBuffer()\nwrite(buffer, event)\nseekstart(buffer)\nretrieved_event = read(buffer, Event)","category":"page"},{"location":"generated/demo/#Plotting","page":"Demonstration","title":"Plotting","text":"","category":"section"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"Here I replicated the event view shown here.","category":"page"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"First I implemented the color mapping defined by the author.","category":"page"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"colormapping1(t) = RGB(cos(π/2 * t), sin(π/2 * t), 0)\ncolormapping2(t) = RGB(0, cos(π/2 * t), sin(π/2 * t))\ncolormapping3(t) = RGB(sin(π/4 * t), 0, cos(π/4 * t))\n\nfunction colormapping(t)\n    t_prime = 3t\n    if t_prime <= 1\n        return colormapping1(t_prime % 1)\n    elseif t_prime <= 2\n        return colormapping2(t_prime % 1)\n    else\n        return colormapping3(t_prime % 1)\n    end\nend","category":"page"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"Then I plotted the hits whose colors are determined by the time they are recorded. I skimmed off hits whose time is 08sigma away from the mean since otherwise all the hits would have almost the same color.","category":"page"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"kw = (; markersize=5,\n      grid=true,\n      xlim=(-1000, 1000), ylim=(-1000, 1000),\n      label=nothing)\n\nusing Statistics, Plots\n\nfunction myplot(event::Event)\n    ts = [hit.t for hit in event.hits]\n    m = mean(ts)\n    s = std(ts)\n    skim = filter(hit -> abs((hit.t - m) / s) < 0.8, event.hits)\n\n    pxz = plot()\n    pyz = plot()\n    for hit in skim\n        t = (hit.t - m) / s / 0.8 / 2 + 0.5\n        c = colormapping(t)\n        scatter!(pxz, (hit.x, hit.z); kw...,\n                 markercolor=c, xlabel=\"x (m)\", ylabel=\"z (m)\")\n        scatter!(pyz, (hit.y, hit.z); kw...,\n                 markercolor=c, xlabel=\"y (m)\", ylabel=\"z (m)\")\n    end\n    plot(pxz, pyz)\nend\n\nmyplot(event)","category":"page"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"","category":"page"},{"location":"generated/demo/","page":"Demonstration","title":"Demonstration","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package implements I/O for IceCube Public Data whose event bytestream is illustrated in this page:","category":"page"},{"location":"","page":"Home","title":"Home","text":"4 bytes - runID(unsigned int)\n4 bytes - year(unsigned int)\n8 bytes - startTime (long) Number of tenths of nanoseconds since the beginning of the year.\n8 bytes - eventLength(float) - Units of microseconds.\n4 bytes - (long) - Number of triggers. This is not a member of the Event class, since it's simply the size of the trigger list. For each trigger the byte structure is given as :\n8 bytes - trigger time (float) - Time of the trigger with respect to the start of the event.\n4 bytes - nchar (int) - Number of characters in the trigger name.\nnchar * 1 byte - The characters that make up the trigger name.\n8 bytes - nhits (long) - Number of hits in the event. The next set consists of nhits*5*8 bytes (one chunk of 8 bytes for each float of q,t,x,y,z).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please note that there is a typo. The number of triggers (long) takes 8 bytes, instead of 4.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Read Demonstration for more.","category":"page"}]
}
